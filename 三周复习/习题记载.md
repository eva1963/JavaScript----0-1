面试题解析

ES6,ES5的区别：

1. ES6新语法：

- let、const
  - 1. let不存在变量提升，变量不允许在声明之前使用
    2. let不允许重复声明
    3. 在全局作用域中基于let声明的变量不是window的一个属性，也就是没有映射机制了
    4. typeof一个未被声明的变量会被报错（之前只会报undefined）
    5. let会形成块级作用域（类似于私有作用域，大部分括号都会形成块级作用域）
- 解构赋值
- "..."展开运算符
- 箭头函数
  - 1.没有arguments，但是可以基于...获取实参集合
  - 2.没有自己的this了，箭头函数中的this是上下文中的this
- ES6的模板字符串
- class
- Promise
- interrator(for of 循环)
- Map/set

重排（回流）和重绘读写分离的理解

思路：1.什么是重排重绘

2.突出他们耗性能

3.突出自己写项目的时候重点注意的这些事情，以及自己的解决方案，解决原理

- 浏览器渲染页面的时候是按照先创建DOM树->再加载css->生成渲染树RenderTree->把渲染树交给浏览器进行绘制，如果后期我们修改了元素的样式（但是没有改变大小和位置），浏览器会把当前元素重新生成渲染树，然后重新渲染，这个机制叫重绘，但是一旦元素的大小或者位置发生了改变，浏览器就要从Dom树开始重新计算渲染，这个机制叫回流（重排），无论是重排还是重绘都非常消耗性能

在以前的项目中，我尽量减少操作DOM引发的回流和重绘问题，常用的解决方案：

- 需要动态向页面中追加元素的时候，基于文档碎片或者先把需要增加的所有元素拼接成字符串，最后统一进行添加；

- 读写分离：把统一修改样式都放到一起执行，新版浏览器都有一个自己检测机制，如果发现下面紧挨着的操作也是修改样式的，它会把所有的修改样式的先存起来，直到遇到一个非修改样式的操作，会把之前存储的同意执行，引发一次回流和重绘
- 当然还有一些其他的操作，这些事最常注意的，我认为减少DOM的回流重回是非常重要的性能优化手段之一

谈谈你对面向对象的理解

1. [js本身就是面向对象编程的]
       js本身就是面向对象编程思想开发出来的语言，我们学习js就是在学习js中的类和实例：例如：
       数组是Array的实例，对象是Object的实例，函数是Function的实例。。。在这些内之类的原型上有很多公共的属性和方法，这些方法可以被实例调用，我们学习js就是学习这些方法。。。
2. [面向对象真实项目中的应用]
       平时的业务逻辑开发我们没有特意去使用类的方式来只有在一些组件或者插件分装的时候才会基于构造函数和原型链实用类和实例完成，例如TAB选项卡，轮播图，摩太长，表单验证等插件，就是这样处理的（之前看过一些类库以及插件的源码，也都是基于面向对象分装的）
3. [面向对象中的一些语法和特点]

      所以面向对象就是基于class或者function创建一个类，执行的时候new执行创建出来一个实例，这样实例就可以调取类上提供的方法，想要基于面向对象进行插件封装，必须掌握关于类的继承、封装和多态，封装就是提取公共的方法，js中没有严格意义的多态，不能进行方法的重写，常用的继承方式有很多，例如：原型继承、call继承、寄生组合继承、es6中的继承等，有些方式会存在一些问题，我项目中后来都是基于class中的extend实现继承的

THIS汇总

@(面试宝典)

THIS：当前方法执行的主体，（谁执行的方法，那么this就是谁，所以THIS和当前方法在哪里创建的或者在哪里执行的都没有必然的关系）

1. 给当前元素绑定方法，当事件触发方法执行的时候，此时方法中的this是当前操作的元素对象“oBox.onclick = function(){this: oBox}”
2. 普通函数执行，函数中的this取决于执行的主体，谁执行的this就是谁（执行主体，方法执行看方法名前面是否有.有的话.前面是谁，this就是谁，没有this就是window）自执行函数一般都是window，在JS的严格模式下，没有点，this是undefined；
3. 构造函数中出现的this一般都是当前类的实例
4. 箭头函数没有执行主体this，它的this就是上下文中的this
5. 在小括号表达式当中，会影响this的指向

    let obj = {
    	fn: function(){
    		console.log(this);
    	}
    }
    obj.fn();	//this是obj
    (12,obj.fn)();	//此时this为window

1. 使用call/apply/bind可以改变this指向。其中非严格模式他们的参数不写或者null，undefined，this都是window；严格模式下，参数里面写的啥就是啥，不写就是undefined；

谈一下你对作用域链和原型链的理解

作用域链

函数形成一个私有的作用域，形参和在当前作用域中声明的变量都属于私有变量，当前私有作用域有自我保护机制，私有变量不受外界影响，但是如果私有作用域中遇到一个非私有的变量，则向他的上级作用域中查找，如果不是上级作用域中私有的，则继续向上查找，一直找到window位置，这种一层层向上查找的机制就叫做作用域链机制

原型链

他也是一种查找机制，实例首先在自己的私有属性中进行属性的查找，如果不是私有属性，基于proto向所属类的原型上进行查找，如果找不到，则继续基于proto向上查找，一直找到Object.prototype为止；例如：obj.hasOwnProperty()这里调取的hasOwnProperty这个属性就是找到Object.prototype才找到的

在原型上拓展方法，最好是直接写在原型上，而且最好用最原始的写法，依赖越少越好；例如： Array.prototype.unique= function(){};

indexOf :找到当前项在数组中出现的为止的索引，找不到的话就是-1；



面向对象：类的继承，封装，多态

1. 封装：把实现一个功能的js代码进行封装，主要目的：低耦合高内聚

1. 多态：

- 重载：方法名相同，参数的个数或者类型不同，此时名字相同的方法叫做方法的重载，js中不存在重载的
- 重写：子类重写父类的方法

1. 继承： 子类继承父类属性和方法

- 原型继承（让子类的原型指向父类的一个实例）
  - 原理是:
    1. 方式：b.prototype = new A();A的实例本身具备父类A的私有属性和共有方法，子类B的原型指向他，那么子类B的实例就可以找到这些属性和方法了
    2. 和传统后台语言不一样，子类继承父类，并不是把父类的属性方法克隆一份副本给子类，，js中的原型机城是让子类和父类建立原型链接的机制，子类的实例在调取父类原型上的方法都是基于原型链的机制完成的；
    3. 不足之处：子类可以重写父类原型上的方法（重写），子类和父类是有关系的，如果一个子类把父类上的方法
    重写了，那么其他的实例也会受到影响；
  - 原型继承存在的问题：
    1. 父类(new A())实例私有的属性以及共有的属性都变成子类实例的共有属性了
    2. 如果子类b的原型上之前有属性方法，重新指向A的实例后，之前的方法就都没用了
- call继承
  - 原理是：
    1. 把父类A作为普通函数执行，让A中的this变为b的实例，相当于给b

  - 弊端：
    1. 把父类A当做普通函数执行，和父类没关系了，仅仅是把A中的属性变为子类B实例的私有属性而已，A原型上的共有属性方法和B以及他的实例没关系了

    ```
    function A(){
    this.x =100;
    }
    A.prototype = {}
    function B(){
        A.call(this);   //基于call
        this.y = 200;

    }
    //B.prototype = A.prototype;一般不这样处理，会导致A的其他实例也受到影响
    //原型继承方式：B.prototype = new A();//创建的Ade实例虽然指向了A的原型，但是实例中不是空的，存放了A的属性，这些属性也会暴露成B的共有属性
    B.prototype = Object.create(A.prototype);   //寄生组合式继承：创建了一个空的对象，且这个对象的原型指向了A的原型，这样B的共有中就不会有A的私有属性了

    let f = new B();
    ```
- 寄生组合式继承

Object.create：内置Object类天生自带的方法：
1. 创建一个空对象
2. 让新创建的空对象的__proto__指向第一个新传递进来的对象（把obj当做新创建的对象的原型）
```
let obj = {name: '哈哈'}
Object.create(obj);//此时obj是新对象的原型
```

- class类实现继承[ES6]
ES6中创建类：
这种语法创建出来的类只能new执行，不能当做普通函数执行
class Fn {
    constructor(n,m) {
        this.x = n;
        this.y = m;
    }
    //只能给Fn的原型上设置方法（只能设置方法不能设置属性）
    getX() {
        console.log(this.x);
    }
    //把Fn当做一个普通对象设置的私有方法，同样也只能设置方法
    static CC(){ }
};
Fn.prototype.AA = 100;
let f = new Fn();


//继承
class A {
    constructor() {
        this.x = 100;
    }

    getX() {
        console.log(this.x);
    }
}

class B extends A {//=>extends类似于实现了原型继承
    constructor() {
        super();//=>类似于CALL继承：在这里SUPER相当于把A的CONSTRUCTOR给执行了，并且让方法中的THIS是B的实例，
        SUPER当中传递的实参都是在给A的CONSTRUCTOR传递
        this.y = 200;
    }

    getY() {
        console.log(this.y);
    }
}

let f = new B();


#### jquery
1. 是一个类库，里面提供了很多的常用方法，有助于我们快速开发，而且这些方法是兼容很多浏览器的，V3不兼容低版本浏览器；
2. 我之前在学习原js的时候或多或少的看了一下源码，刚毕业的时候jquery用的比较多，但是最近两年一直都在用框架开发，JQ中的常用方法忘差不多了；
之前看源码的时候，发现jquery就是一个类，而$()就是创建一个实例，而这个实例就是基于内置方法MakeArray创建的类数组，，JQ提供的方法有两部分，一部分
是放在原型上供实例调取使用，一部分是放在对象上个，直接$.XXX即可使用，想要后期自己扩展方法（包括JQ写插件），都可以基于extend这个方法扩展
JQ中提供了动画，事件，AJAX等常用方法，我学习JQ源码比较注重里面的一些封装和编程思想，比如发布订阅设计模式，我就是依据JQ的$.Callbacks学习研究的，所以自学JQ给我带来了很多好处

#### 谈谈你对闭包的理解
闭包是js中一个非常重要的机制，我们很多的编程思想和业务逻辑，设计模式都是基于闭包完成的，以下是我对闭包的理解，它就是函数执行产生一个私有作用域，它里面的私有变量和外界互不干扰唉，而且作用域不销毁，这些私有变量值也都保存下来了，所以整体来说闭包就是为了保护和保存变量的；
实际项目开发当中，很多地方使用到了闭包，例如：
1. 循环时间绑定，由于事件是异步编程的，我们点击执行方法，我们此时在循环的时候把索引存储起来，可以用自定义属性的方式也能闭包的方式，后期需要使用的时候只需向上级作用于查找即可
2. 平时做业务的时候，我们一般都是基于单例模式来管理代码的，这种单例的构建就应用到了闭包
3. 之前在学习资料上了解了柯力化函数思想，他其实就是基于闭包完成的
```
Function.prototype.bind = function(context,...arg)){
    return (context,...arg) => {
        fn.call(context,...arg);
    }
}
document.onclick = fn.bind();
```
4.闭包比较占内存，我们应该尽量减少对他的使用，但是有些地方必须用闭包；



